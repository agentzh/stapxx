#!/usr/bin/env stap++

# Capture ssl session tickets.

@use nginx.array
@use openssl

probe begin {
    printf("Tracing process %d ($^exec_path).\nExit on first capture. Or hit Ctrl-C to end.\n", target())
}

// print 16-byte key name
function print_key_name(name) {
    printf("key name: ");
    $*n := @cast(name, "unsigned char", "$^exec_path")
    for (i=0; i<16; i++) {
       printf("%02x", $*n[i])
    }
    printf("\n")
}

// print session ticket content
function print_session_ticket_key(key) {
    $*k := @cast(key, "ngx_ssl_session_ticket_key_t", "$^exec_path")
    print_key_name($*k->name)
    // could be extended to print out other cipher states
}

probe @pfunc(ngx_ssl_session_ticket_key_callback).return {
    keys_index = @var("ngx_ssl_session_ticket_keys_index@src/event/ngx_event_openssl.c")
    num = get_ssl_ex_data_len($ssl_conn->ctx)
    if (keys_index > num) {
        printf("Error: ticket key list is not supported")

    } else {
        keys = get_ssl_ex_data_item($ssl_conn->ctx, keys_index)
        keys_len = get_ngx_array_len(keys)
        if (keys_len <= 0) {
            printf("Error: empty key list")

        } else {
            key_ptr = get_ngx_array_elts(keys)
            printf("keys len %d\n", keys_len)
            for (i=0; i<keys_len; i++) {
                key = &@cast(key_ptr, "ngx_ssl_session_ticket_key_t",
                             "$^exec_path")[i]
                if (i == 0) {
                    printf("enc key:\n")
                } else {
                    printf("dec key:\n")
                }
                print_session_ticket_key(key)
            }
        }
    }
    exit()
}
